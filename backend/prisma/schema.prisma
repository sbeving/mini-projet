// Prisma schema for LogChat
// Database: PostgreSQL

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/// User roles for access control
enum Role {
  ADMIN
  STAFF
  USER
}

/// User account for authentication
model User {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
  
  /// User email (unique identifier)
  email     String   @unique
  
  /// Hashed password
  password  String
  
  /// Display name
  name      String
  
  /// User role
  role      Role     @default(USER)
  
  /// Whether the account is active
  active    Boolean  @default(true)
  
  /// Last login timestamp
  lastLogin DateTime? @map("last_login")
  
  /// Sessions for this user
  sessions     Session[]
  
  /// Chat sessions for this user
  chatSessions ChatSession[]
  
  /// Activity logs for this user
  activities   UserActivity[]
  
  /// Log sources created by this user
  logSources   LogSource[]
  
  /// Integrations created by this user
  integrations Integration[] @relation("IntegrationCreator")
  
  /// Audit logs for this user
  auditLogs    AuditLog[]    @relation("AuditLogs")
  
  /// Alert rules created by this user
  alertRules   AlertRule[]   @relation("AlertRuleCreator")
  
  /// Alerts acknowledged by this user
  acknowledgedAlerts Alert[]  @relation("AlertAcknowledger")

  @@index([email])
  @@index([role])
  @@map("users")
}

/// Session for authenticated users
model Session {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now()) @map("created_at")
  expiresAt DateTime @map("expires_at")
  
  /// Session token (hashed)
  token     String   @unique
  
  /// Associated user
  userId    String   @map("user_id")
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  /// User agent string
  userAgent String?  @map("user_agent")
  
  /// IP address
  ipAddress String?  @map("ip_address")

  @@index([token])
  @@index([userId])
  @@index([expiresAt])
  @@map("sessions")
}

/// Represents an ingested application log entry
model Log {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now()) @map("created_at")
  
  /// Timestamp from the log itself (parsed or provided)
  timestamp DateTime
  
  /// Log level: INFO, WARN, ERROR, DEBUG, FATAL, etc.
  level     String
  
  /// Service/application name that generated the log
  service   String
  
  /// The main log message
  message   String
  
  /// The original raw log line/payload
  raw       String
  
  /// Additional metadata (JSON blob)
  meta      Json?

  @@index([timestamp])
  @@index([level])
  @@index([service])
  @@index([timestamp, level])
  @@map("logs")
}

/// Activity type enum
enum ActivityType {
  LOGIN
  LOGOUT
  PAGE_VIEW
  CHAT_MESSAGE
  CHAT_SESSION_START
  CHAT_SESSION_END
  DASHBOARD_VIEW
  LOG_SEARCH
  LOG_VIEW
  EXPORT
  SETTINGS_CHANGE
}

/// Chat session - stores conversation history
model ChatSession {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
  
  /// Session title (auto-generated from first message)
  title     String
  
  /// User who owns this chat session
  userId    String   @map("user_id")
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  /// Messages in this session
  messages  ChatMessage[]
  
  /// Whether session is archived
  archived  Boolean  @default(false)
  
  /// Total messages count (denormalized for performance)
  messageCount Int   @default(0) @map("message_count")

  @@index([userId])
  @@index([createdAt])
  @@index([userId, createdAt])
  @@map("chat_sessions")
}

/// Chat message - individual messages in a chat session
model ChatMessage {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now()) @map("created_at")
  
  /// The chat session this message belongs to
  sessionId String   @map("session_id")
  session   ChatSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  
  /// Message role: user or assistant
  role      String
  
  /// Message content
  content   String
  
  /// Response time in ms (for assistant messages)
  responseTime Int?  @map("response_time")
  
  /// Tokens used (if tracked)
  tokensUsed   Int?  @map("tokens_used")

  @@index([sessionId])
  @@index([createdAt])
  @@map("chat_messages")
}

/// User activity tracking for analytics
model UserActivity {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now()) @map("created_at")
  
  /// User who performed the activity
  userId    String   @map("user_id")
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  /// Type of activity
  type      ActivityType
  
  /// Page or resource accessed
  path      String?
  
  /// Duration in seconds (for page views, sessions)
  duration  Int?
  
  /// Additional metadata
  meta      Json?
  
  /// IP address
  ipAddress String?  @map("ip_address")
  
  /// User agent
  userAgent String?  @map("user_agent")

  @@index([userId])
  @@index([type])
  @@index([createdAt])
  @@index([userId, createdAt])
  @@index([userId, type])
  @@map("user_activities")
}

/// Platform usage statistics (daily aggregates)
model UsageStats {
  id        String   @id @default(cuid())
  
  /// Date for these stats
  date      DateTime @db.Date
  
  /// Total active users
  activeUsers    Int @default(0) @map("active_users")
  
  /// Total new users
  newUsers       Int @default(0) @map("new_users")
  
  /// Total chat sessions
  chatSessions   Int @default(0) @map("chat_sessions")
  
  /// Total chat messages
  chatMessages   Int @default(0) @map("chat_messages")
  
  /// Total logs ingested
  logsIngested   Int @default(0) @map("logs_ingested")
  
  /// Total API calls
  apiCalls       Int @default(0) @map("api_calls")
  
  /// Average session duration (seconds)
  avgSessionDuration Int @default(0) @map("avg_session_duration")

  @@unique([date])
  @@index([date])
  @@map("usage_stats")
}

/// Log source types
enum LogSourceType {
  API
  WEBHOOK
  SYSLOG
  AGENT
  CLOUD
  DATABASE
}

/// Integration status
enum IntegrationStatus {
  ACTIVE
  INACTIVE
  FAILED
  PENDING
}

/// Log Source - API keys and webhook endpoints for log ingestion
model LogSource {
  id          String   @id @default(cuid())
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  /// Source name
  name        String
  
  /// Description
  description String?
  
  /// Source type
  type        LogSourceType @default(API)
  
  /// API Key (visible to user once)
  apiKey      String   @unique
  
  /// Hashed API key for validation
  apiKeyHash  String
  
  /// IP whitelist (empty = allow all)
  allowedIps  String[] @default([])
  
  /// Webhook URL (if type = WEBHOOK)
  webhookUrl  String?
  
  /// Webhook secret for HMAC validation
  webhookSecret String?
  
  /// Active status
  isActive    Boolean  @default(true)
  
  /// Rate limit (requests per window)
  rateLimit   Int      @default(1000)
  
  /// Rate limit window (seconds)
  rateLimitWindow Int  @default(60)
  
  /// Custom metadata
  metadata    Json?
  
  /// Creator
  createdById String
  createdBy   User     @relation(fields: [createdById], references: [id])
  
  /// Last time used
  lastUsedAt  DateTime?
  
  /// Usage stats
  usageStats  LogSourceUsage[]

  @@index([createdById])
  @@index([isActive])
  @@index([type])
  @@map("LogSource")
}

/// Integration - external service connections
model Integration {
  id          String   @id @default(cuid())
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  /// Integration name
  name        String
  
  /// Integration type (slack, pagerduty, email, etc.)
  type        String
  
  /// Status
  status      IntegrationStatus @default(ACTIVE)
  
  /// Configuration (service-specific)
  config      Json
  
  /// Encrypted credentials
  credentials Json?
  
  /// IP whitelist for callbacks
  allowedIps  String[] @default([])
  
  /// Webhook URL for this integration
  webhookUrl  String?
  
  /// Webhook secret
  webhookSecret String?
  
  /// Retry policy
  retryPolicy Json?
  
  /// Last successful sync
  lastSyncAt  DateTime?
  
  /// Last error time
  lastErrorAt DateTime?
  
  /// Last error message
  lastErrorMessage String?
  
  /// Total syncs
  syncCount   Int      @default(0)
  
  /// Total errors
  errorCount  Int      @default(0)
  
  /// Creator
  createdById String
  createdBy   User     @relation("IntegrationCreator", fields: [createdById], references: [id])

  @@index([createdById])
  @@index([status])
  @@index([type])
  @@map("Integration")
}

/// Log source usage tracking
model LogSourceUsage {
  id            String   @id @default(cuid())
  timestamp     DateTime @default(now())
  
  /// Source
  logSourceId   String
  logSource     LogSource @relation(fields: [logSourceId], references: [id], onDelete: Cascade)
  
  /// Metrics
  logsReceived  Int      @default(0)
  bytesReceived Int      @default(0)
  requestsCount Int      @default(0)
  errorsCount   Int      @default(0)
  
  /// Source IP
  sourceIp      String?
  
  /// User agent
  userAgent     String?

  @@index([logSourceId, timestamp])
  @@index([timestamp])
  @@map("LogSourceUsage")
}

/// Audit log for all admin actions (CISO requirement)
model AuditLog {
  id         String   @id @default(cuid())
  timestamp  DateTime @default(now())
  
  /// User who performed the action
  userId     String
  user       User     @relation("AuditLogs", fields: [userId], references: [id])
  
  /// Action performed
  action     String
  
  /// Resource type (log_source, integration, user, etc.)
  resource   String
  
  /// Resource ID
  resourceId String?
  
  /// Additional details
  details    Json?
  
  /// IP address
  ipAddress  String?
  
  /// User agent
  userAgent  String?

  @@index([userId])
  @@index([timestamp])
  @@index([action])
  @@index([resource])
  @@map("AuditLog")
}

/// Alert rules for automated monitoring
model AlertRule {
  id          String   @id @default(cuid())
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  /// Rule name
  name        String
  
  /// Description
  description String?
  
  /// Condition (query/filter)
  condition   Json
  
  /// Severity when triggered
  severity    String   @default("INFO")
  
  /// Active status
  isActive    Boolean  @default(true)
  
  /// Notification channels (email, slack, etc.)
  notificationChannels String[] @default([])
  
  /// Cooldown period (minutes)
  cooldownMinutes Int   @default(5)
  
  /// Last triggered
  lastTriggeredAt DateTime?
  
  /// Trigger count
  triggerCount    Int      @default(0)
  
  /// Creator
  createdById String
  createdBy   User     @relation("AlertRuleCreator", fields: [createdById], references: [id])
  
  /// Alerts triggered by this rule
  alerts      Alert[]

  @@index([createdById])
  @@index([isActive])
  @@map("AlertRule")
}

/// Triggered alerts
model Alert {
  id          String   @id @default(cuid())
  createdAt   DateTime @default(now())
  
  /// Rule that triggered this alert
  ruleId      String
  rule        AlertRule @relation(fields: [ruleId], references: [id], onDelete: Cascade)
  
  /// Log that triggered (if applicable)
  logId       String?
  
  /// Severity
  severity    String
  
  /// Alert message
  message     String
  
  /// Additional details
  details     Json?
  
  /// Acknowledged status
  isAcknowledged Boolean @default(false)
  
  /// Who acknowledged
  acknowledgedById String?
  acknowledgedBy   User?   @relation("AlertAcknowledger", fields: [acknowledgedById], references: [id])
  
  /// When acknowledged
  acknowledgedAt   DateTime?

  @@index([ruleId])
  @@index([logId])
  @@index([isAcknowledged])
  @@index([createdAt])
  @@map("Alert")
}

